#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//int arr[10] = { 0 };
//printf("%p\n", arr);
//printf("%p\n", &arr[0]);
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);
//	printf("%p\n", arr+1);
//
//    printf("%p\n", &arr[0]);
//	printf("%p\n", &arr[0]+1);
//
//	printf("%p\n", &arr);
//	printf("%p\n", &arr+1);
//
//	//int sz = sizeof(arr);
//	//printf("%d\n", sz);
//	return 0;
//}
//数组名通常表示的都是数组首元素地址。
//但是有两个例外：
//1.sizeof（数组名）sizeof里面单独放一个数组名的时候是一个例外，
//这里的数组名表示整个数组，计算的是整个数组的大小。
//2. & 数组名，这里的数组名表示的依然是整个数组，所以 & 数组名，
//取出的是整个数组的地址。
//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	int (*p2)[10] = &arr;
//	return 0;
//}
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int(*p)[10] = &arr;
//
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", *(*p+i));
//
//	}
//	return 0;
//}
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//	return 0;
//}
//void print1(int arr[3][5], int r, int c)
//{
//	int i = 0;
//	for (i = 0; i < r; i++)
//	{
//		int j = 0;
//		for (j = 0; j < c; j++)
//		{
//			printf("%d ",arr[i][j]);
//
//		}
//		printf("\n");
//	}
//}
//void print2(int(*p)[5], int r, int c)
//{
//	int i = 0;
//	for (i = 0; i < r; i++)
//	{
//		int j = 0;
//		for (j = 0; j < c; j++)
//		{
//			printf("%d ", *(*(p + i) + j));
//		}
//		printf("\n");
//	}
//}
//int main()
//{
//	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };
//	print2(arr,3,5);
//	return 0;
//}
//# 前言
//
//# 一、指针数组
//在初阶我们学习了指针数组，指针数组是一个存放指针的数组，这里我们简单复习下。
//指针数组：是数组，是用来存放指针的数组，
//
//```c
//int arr[10];//整形数组
//char ch[5];//字符数组
////指针数组
//int* arr2[6];//这是一个存放整型指针的数组
////arr2数组名，6个元素，数组的每个元素是int*类型的值
////每个元素都是int* 类型的值
//char* arr3[5];//存放字符指针的数组
//```
//
//> 指针数组有什么用呢？
//
//
//```c
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 2,3,4,5,6 };
//	int arr3[] = { 3,4,5,6,7 };
//
//	int* parr[] = { arr1,arr2,arr3 };
//
//	return 0;
//}
//```
//arr1相当于1的地址, arr2相当于2的地址, arr3相当于3的地址。arr1 arr2 arr3都是整型的地址，所以parr这个数组应该是int* 类型的。
//
//
//![在这里插入图片描述](https://img-blog.csdnimg.cn/c878ec82564c4bdcbeaadcab4a8021c9.png)
//
//```c
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 2,3,4,5,6 };
//	int arr3[] = { 3,4,5,6,7 };
//
//	int* parr[3] = { arr1,arr2,arr3 };
//
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(parr[i] + j));//也可以写成parr[i][j]
//		}
//		printf("\n");
//	}
//	return 0;
//}
//```
//
//		> 打印出来结果：
//
//	```c
//	1 2 3 4 5
//	2 3 4 5 6
//	3 4 5 6 7
//	```
//
//	# 二、数组指针
//	## 1.数组指针的定义
//	数组指针是指针
//
//	> **类比： * *
//
//	整型指针――指向整型的指针
//	字符指针――指向字符的指针
//	* *数组指针――指向数组的指针 * *
//
//	```c
//	int* p1[10];
//int(*p2)[10];
////p1, p2分别是什么？
//```
//
//![在这里插入图片描述](https://img-blog.csdnimg.cn/588ad0a69cae496887f2cd844dd98502.png)
//想要使用数组指针，我们还得先把数组名深入理解一下：
//## 2. & 数组名vs数组名
//
//```c
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);
//	printf("%p\n", &arr[0]);
//	return 0;
//}
//```
//
//> 打印结果：
//
//```c
//006FFAD0
//006FFAD0
////数组名就是首元素地址
//```
//
//```c
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);
//	printf("%p\n", &arr[0]);
//	int sz = sizeof(arr);
//	printf("%d\n", sz);
//	return 0;
//}
//```
//
//> 打印结果：
//
//```c
//006FFAD0
//006FFAD0
//40
//```
//
//
//
//当我们这样去写的时候，有的同学就会产生歧义，刚刚我们说了，数组名是首元素地址，如果数组名是首元素地址，首元素地址是地址，所以就是4个字节或者8个字节，那sizeof算出来应该是4 或者 8 ，但是发现结果是40，所以两个地址是一模一样，好像认定了数组名就是首元素地址，但是当我们写sizeof（arr）的时候发现数组名好像不是首元素地址，这个我们要注意：
//* *数组名通常表示的都是数组首元素地址。**
//
//> **但是有两个例外： * *
//
//1.sizeof（数组名）sizeof里面单独放一个数组名的时候是一个例外，这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节。
//2. & 数组名，这里的数组名表示的依然是整个数组，所以 & 数组名，取出的是整个数组的地址。
//![在这里插入图片描述](https://img-blog.csdnimg.cn/e5acc4b9de244f0ea4d704ea470cfdf8.png)
//
//区别请看下面代码：
//```c
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);
//	printf("%p\n", arr + 1);
//
//	printf("%p\n", &arr[0]);
//	printf("%p\n", &arr[0] + 1);
//
//	printf("%p\n", &arr);
//	printf("%p\n", &arr + 1);
//
//	return 0;
//}
//```
//
//> 打印结果：
//
//
//```c
//00BBFB70
//00BBFB74
//00BBFB70
//00BBFB74
//00BBFB70
//00BBFB98
//```
//我们观察，arr 和arr + 1差了4个字节， & arr[0] 和 & arr[0] + 1差了4个字节，我们发现首元素地址 + 1，加了4个字节，因为我们知道这个数组每个元素都是int类型的，因为数组名表示首元素地址的话，这里就是int类型的地址，那arr的类型是int * ，而int * 的指针 + 1跳过四个字节，所以都是相差4。
//那 & arr 和 & arr + 1 相差40，0x28―― > 40, & 数组名，取出的是整个数组的地址，& arr + 1 表示跳过整个数组。
//
//
//
//> **整形指针是用来存放整型的地址
//字符指针用来存放字符的地址
//数组指针用来存放数组的地址 * *
//
//
//```c
//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	int(*p2)[10] = &arr;//数组指针
//	return 0;
//}
//```
//## 3.数组指针的使用
//
//```c
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int(*p)[] = &arr;//这样写是不行的
//	return 0;
//}
//```
//
//![在这里插入图片描述](https://img-blog.csdnimg.cn/f2a529bd70024242adf7e3ef76c8f43a.png)
//warning ： “int(*)[0]”和“int(*)[10]”数组的下标不同，int（* ）[]认为[]里面是0，两个对不上，所以必须写清楚几个元素，不能省略10！
//
//
//
//
//
//
//```c
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int(*p)[10] = &arr;
//
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", *(*p + i));
//
//	}
//	return 0;
//}
//```
//
//p是指向数组的，* p其实就相当于数组名
//数组名，又是数组首元素的地址，所以* p本质上数组首元素地址
//
//
//	> 打印结果：
//
//
//	```c
//	1 2 3 4 5 6 7 8 9 10
//	```
//	我们发现这种用法非常的别扭，这种用方法很不好，下面我们看看正常的写法：
//
//	```c
//	int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//	return 0;
//}
//```
//这种写法就很容易让人理解。
//
//** 数组指针多用在 二维三维数组里**
//用数组指针写的话
//
//	> 大概思路：
//
//	![在这里插入图片描述](https://img-blog.csdnimg.cn/d1fcea384b8143daa2cf96333beea92c.png)
//
//
//```c
////用数组传参实现：
//void print1(int arr[3][5], int r, int c)
//{
//	int i = 0;
//	for (i = 0; i < r; i++)
//	{
//		int j = 0;
//		for (j = 0; j < c; j++)
//		{
//			printf("%d ", arr[i][j]);
//
//		}
//		printf("\n");
//	}
//}
//int main()
//{
//	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };
//	print1(arr, 3, 5);
//	return 0;
//}
////数组指针的写法：
//void print2(int(*p)[5], int r, int c)
//{
//	int i = 0;
//	for (i = 0; i < r; i++)
//	{
//		int j = 0;
//		for (j = 0; j < c; j++)
//		{
//			printf("%d ", *(*(p + i) + j));
//		}
//		printf("\n");
//	}
//}
//int main()
//{
//	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };
//	print2(arr, 3, 5);
//	return 0;
//}
//```
//
//
//
//		> 打印结果：
//
//
//	```c
//	1 2 3 4 5
//	2 3 4 5 6
//	3 4 5 6 7
//	```
//
//	> **再捋一遍思路： * *
//
//	![在这里插入图片描述](https://img-blog.csdnimg.cn/52b2ec90cc714e628e2601d48f10b6d0.png)
//p我们说指向的是第一行，p + 1为什么就跳过一行呢？
//
//
//当我们有int(*p)[5]这样一个指针的时候，
//p的类型是 : int(*)[5];
//p 是指向一个整型数组的，数组是5个元素 int[5]
//p + 1就是跳过一个5个int元素的数组。