#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//初始化数组元素为1
////数组下标的写法：
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		arr[i] = 1;
//	}
//	return 0;
//}
//指针的写法
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int* p = arr;
//	for (i = 0; i < sz; i++)
//	{
//		*p = 1;
//		p++;
//	}
//	return 0;
//}
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n", &arr[9] - &arr[0]);
//	return 0;
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[5] = { 0 };
//	printf("%d\n",&ch[0] - &arr[5]);
//	return 0;
//}
#include<string.h>

//版本1：
//int my_strlen(char* str)//找\0
//{
//	int count = 0;
//	while (*str != '\0')
//	{
//		count++;
//		str++;
//	}
//	return count;
//}
//指针-指针
//其实你要知道\0的地址和起始位置的地址，相减就可以了
//int my_strlen(char* str)
//{
//	char* start = str;
//	while (*str != '\0')
//	{
//		str++;
//	}
//	return str - start;
//}
//int main()
//{
//	int len = my_strlen("abcdef");//a b c d e f \0
//	printf("%d\n", len);
//	return 0;
//}
//#define N_VALUES 5
//int main()
//{
//	float values[N_VALUES];
//	float* vp;
//	for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
//	{
//		*vp = 0;
//	}
//	return 0;
//}
//# 一、指针运算
//
//## 1.指针 + -整数
//
//```c
//#define N_VALUES 5
//float values[N_VALUES];
//float* vp;
////指针+-整数；指针的关系运算
//for (vp = &values[0]; vp < &values[N_VALUES];)
//{
//	*vp++ = 0;
//}
//```
//
//> ** 分析代码：**
//
//
//
//结合下图分析， define N_VALUES 5实质是就是定义 N_VALUES这个符号的值就是5，float values[N_VALUES]，大家注意其实这个地方就是定义values这个数组是五个元素且没有初始化，然后float * vp，vp也没有初始化，此时此刻vp就是野指针了，但是我们暂时还没解引用它，危险还没有发生，紧接着往下看，vp初始化了，将values[0]的地址赋值给vp，vp有指向了，此时此刻vp不再是野指针了，初始化完后判断 vp < &values[N_VALUES]即vp小于values下标为5这个元素的地址，我们知道数组的地址是由低到高变化的，所以我们知道vp的地址一定是小于values[N_VALUES]的地址的，这里两个指针比较大小，叫做指针的关系运算，  vp < &values[N_VALUES]的话就进入循环，* vp++ = 0，++优先级高，但是他是后置的先使用再++，所以vp++这个表达式的值本身是vp的值，所以解引用vp的时候，还是指向原位置的，将0放进去，然后++的效果产生，vp++，它指向它的下一个位置去了（用红笔表示它指向的下一个位置），不断++，不断去往下一个位置，当vp走到蓝色笔所指向的位置时，大家注意vp小于values[N_VALUES]的地址，已经不成立了，所以结束循环。这一块不仅用到了指针 + -整数运算还用到了关系运算。
//	![在这里插入图片描述](https://img-blog.csdnimg.cn/ca841f352daa442d84e1742c5fb73b96.png)
//
//
//
//>** 应用：**
//
//
//将数组元素初始化1：
//```c
////数组下标的写法：
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		arr[i] = 1;
//	}
//	return 0;
//}
//```
//
//```c
////指针的写法1：
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int* p = arr;
//	for (i = 0; i < sz; i++)
//	{
//		*p = 1;
//		p++;
//	}
//	return 0;
//}
////指针的写法2：
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int* p = arr;
//	for (i = 0; i < sz; i++)
//	{
//		*(p + i) = 1;
//	}
//	return 0;
//}
//```
//
//## 2.指针 - 指针
//
//```c
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n", &arr[9] - &arr[0]);
//	return 0;
//}
//```
//![在这里插入图片描述](https://img-blog.csdnimg.cn/79523f4c20c3467f82d989860a11f818.png)
//程序一走，发现得到的结果是9，那么9是如何得来的呢？
//取出下标为0和9的地址，这两个地址之间有9个元素，36个字节，实质上呢，** 指针 - 指针得到的是指针和指针之间元素的个数。 * *那反过来我们用下标为0的元素减去下标为9的元素，这个时候我们发现结果是 - 9，那就可以这样理解： * *| 指针 - 指针 | 得到的是指针和指针之间元素的个数。 * *
//![在这里插入图片描述](https ://img-blog.csdnimg.cn/b7dd3855d5ff4af4a5957aad73146d35.png)
//
//
//	不是所有的指针都能够相减的，指向同一块空间的两个指针才能相见，这样才有意义。下面的指针相减就没有意义
//
//	```c
//	int main()
//{
//	int arr[10] = { 0 };
//	char ch[5] = { 0 };
//	printf("%d\n", &ch[0] - &arr[5]);
//	return 0;
//}
//```
//这种写法没道理也没意义，本质上是错误的。
//
//	> ** 应用：**
//
//	求字符串长度，我们之前是使用库函数
//
//	```c
//#include<string.h>
//	int main()
//{
//	int len = strlen("abcdef");
//	printf("%d\n", len);
//	return 0;
//}
//```
//![在这里插入图片描述](https://img-blog.csdnimg.cn/fd9ba82efd804f22a350fc0427b8383d.png)
//那如果我们自己实现一个求字符产长度的函数呢？
//
//```c
////版本1：
//int my_strlen(char* str)//找\0
//{
//	int count = 0;
//	while (*str != '\0')
//	{
//		count++;
//		str++;
//	}
//	return count;
//}
//int main()
//{
//	int len = my_strlen("abcdef");//a b c d e f \0
//	printf("%d\n", len);
//	return 0;
//}
//```
//
//```c
////版本2：指针-指针
////其实你要知道\0的地址和起始位置的地址，相减就可以了
//int my_strlen(char* str)
//{
//	char* start = str;
//	while (*str != '\0')
//	{
//		str++;
//	}
//	return str - start;
//}
//int main()
//{
//	int len = my_strlen("abcdef");//a b c d e f \0
//	printf("%d\n", len);
//	return 0;
//}
//```
//![在这里插入图片描述](https://img-blog.csdnimg.cn/34e291b9e89c4b8cbf2689385621f0d6.png)
//那指针 + 指针的运算能不能运算呢？
//想象一下指针 + 指针就是地址 + 地址，有什么意义呢？其实没什么太大意义，生活中也有相似的例子，比如：
//日期
//日期 + 天数有意义，日期 - 天数有意义，日期 - 日期有意义，那么日期加日期是不是就感觉很奇怪了，所以地址 + 地址是没有什么意义的。
//## 3.指针的关系运算
//指针的关系运算其实就是比较大小。
//
//```c
//#define N_VALUES 5
//int main()
//{
//	float values[N_VALUES];
//	float* vp;
//	for (vp = &values[N_VALUES]; vp > &values[0];)
//	{
//		*--vp = 0;
//	}
//	return 0;
//}
//```
//分析：
//![在这里插入图片描述](https://img-blog.csdnimg.cn/12b898a05de04e3e9b363bc35c1539e5.png)
//我们可以简化代码：
//
//```c
//#define N_VALUES 5
//int main()
//{
//	float values[N_VALUES];
//	float* vp;
//	for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
//	{
//		*vp = 0;
//	}
//	return 0;
//}
//```
//先给vp赋值N_VALUES - 1，下标就为4 ，大于等于下标为0的元素，然后改成0，改完后vp--，直到vp指向valuse[0]的地址，把所有元素都改成0了，再--，就指向下标为0的前面有个一个元素，这个时候循环就结束了。
//
//这样简化后的代码实际在绝大部分编译器上是可以顺利完成任务的，然而我们还是应该避免这样写，因为标准并不保证它可行。
//* *标准规定：
//允许指向数组元素的指针与指针向数组最后一给元素后面的内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较 * *
//
//
//假设红色框框是arr数组，相对于arr数组来说p2指针和p3指针都是越界了 ，p2向后越界，p3向前越界，标准规定说允许p1和p2比，但是不允许p1和p3比。实际理论上讲是没什么区别的，但是标准是那样规定的。
//![在这里插入图片描述](https://img-blog.csdnimg.cn/36d84d21400548d9b78688fc033840cd.png)
//
//指针：野指针
//概念：
//野指针就是指指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
//
//一、野指针
//野指针的成因
//1.指针未初始化
//
//int main()
//{
//	int* p;
//	*p = 10;
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//这个代码指针变量p没有初始化 ，就意味着，没有明确的指向。
//
//一个局部变量不初始化的话，放的是随机值：0xcccccccc（函数栈帧的空间会被初始化一部分内容）
//
//p里面放的是0xcccccccc这样的值，这样一个值放到p里面的时候意味着放的是一个地址，就是把0xcccccccc这样一个值当成p里面放的那个的地址，p即对那个随机值的地址进行解引用，访问一块空间，而那个地址所指向的空间并不是p的，即那个地址是一个非法的地址，所以p通过那个地址所找到的空间也不属于p，属于非法访问内存。
//
//当我们用上面这种情况下的p时，这里的p就是野指针。
//
//2.指针越界访问
//
//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;//&arr[0]
//	int i = 0;
//	for (i = 0; i <= 10; i++)
//	{
//		*p = i;
//		p++;
//	}
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//8
//9
//10
//11
//12
//
//当指针指向的范围超出数组arr的范围时，p就是野指针。
//
//3.指针指向的空间释放
//
//int* test()
//{
//	int a = 10;
//	return &a;
//}
//int main()
//{
//	test();
//
//	int* p = test();
//
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//8
//9
//10
//11
//12
//13
//首先我们进入main函数要调用test（），进去调用的时候创建了a，a是一个局部变量，将10放进a里，假设a的地址是0x0012ff40，而return & a，将其返回到p里面去了，注意，这个时候p里面放的就是0x0012ff40这个地址，但是当我们把这个地址返回来的时候，这个a空间因为它是局部的，一旦出了test这个函数的时候，它就销毁了，所谓的销毁，就是把这块内存还给操作系统里，大家注意它把那块空间还给了操作系统所以我们是不可以使用它的，但是p里面还保存了这块空间的地址，那就是说p其实是有能力找到这块空间，但是当p找到这块空间的时候，是不能访问使用这块空间的。所以p在这块也是野指针。
//
//如何规避野指针
//1.指针初始化
//2.小心指针越界
//3.指针指向的空间释放及时值NULL
//4.避免返回局部变量的地址
//5.指针使用之前检查有效性
//
//int main()
//{
//	int a = 0;
//	int* p = &a;
//	*p = 20;
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//明确的给指针进行初始化，但是有时候会出现一种情况，暂时不知道给指针初始化什么值，那么此时我们给它初始化成空指针。
//
//int main()
//{
//	int* p2 = NULL;//NULL就是0
//	*p2 = 100；
//		return 0;
//}
//1
//2
//3
//4
//5
//6
//
//此时，我们调试起来发现，程序崩溃了，写入访问权限冲突，什么意思呢，就是内存里面有些地址是不能访问的，比如说NULL地址是不允许访问的，所以我们以后在使用指针的时候，当一个指针变量不知道初始化什么值的时候，给它初始化成空指针，注意，当用这个指针的时候如下代码：
//
//int main()
//{
//	int* p3 = NULL;
//	if (p3 != NULL)
//	{
//		*p3 = 100;
//	}
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//8
//9
//因为我们不知道给p3赋什么值，所以我们给p3先赋了空指针，我们再用它之前判断它如果不是空指针，如果不是，那我们就用它，那此时 * p3解引用然后赋100进去是可以的，因为它不等于空指针说明它已经有有效的指向了，所以就可以解引用它，这样做就可以在一定程度上避免指针出现问题。但是这种写法是避免不了指针指向的范围超出数组arr的范围时这种错误的。
//
//我们可以野指针看成一条野狗，你在路上看到野狗，害怕它伤人，你会怎么办呢，是我的话，我可能是想办法把这条野狗想办法栓到一棵树上，这个时候，如果没人靠近野狗的话，它是不是就是不会伤害人，当我们不知道给p2赋什么值的时候，就给它赋空指针，就相当于把野狗拴到一个树上，这个时候相对比较安全了，但是这个时候，你明明看到这个野狗栓到树上了，你非得跑过去在树底下尿尿，这个时候就相当于上面的解引用p2，并赋值100，这个时候野狗是一定会伤害你的。
//
//指针的问题五花八门在使用的时候是非常危险的，建议大家在使用指针的时候一定要小心谨慎！！！
//――――――――――――――――
//版权声明：本文为CSDN博主「这代码还能再酷一点吗」的原创文章，遵循CC 4.0 BY - SA版权协议，转载请附上原文出处链接及本声明。
//原文链接：https ://blog.csdn.net/m0_68800221/article/details/125321794
//文章目录
//指针
//一、指针是什么？
//二、指针和指针类型
//1.指针解引用
//2.指针 + -整数
//指针
//一、指针是什么？
//指针是什么？
//1
//指针理解的2个要点：
//1.指针是内存中一个最小单元的编号，也就是地址。
//简单说一下：内存空间如何管理？
//切割成内存单元，一个内存单元大小是1byte（字节）
//
//
//2.平时口语中所说的指针，通常指的是指针变量，是用来存放内存的变量。
//
//总结：指针就是地址，口语中说的指针通常指的是指针变量，是用来存放内存地址的变量。平时写代码时，指针变量 里面存放的是地址 ，而通过这个地址，就可以找到一个内存单元.
//那么问题来了：
//1.一个小的单元到底是多大？（1个字节）
//2.如何编址？
//通过仔细的计算和权衡我们发现一个字节给的一个对应的地址是比较合适的。
//对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电压和低电压就是（1或者0）
//那么32根地址线产生的地址就会是：
//00000000 00000000 00000000 00000000
//00000000 00000000 00000000 00000001
//00000000 00000000 00000000 00000002
//…
//111111111 111111111 111111111 111111111
//这里就有2的32次方个地址
//每个地址标识一个字节，那么我们就可以给2 ^ 32 / 1024 / 1024 / 1024GB == 4G的空闲进行编址。
//这里我们就明白：
//1.在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所以一个指针变量的大小就应该是4个字节。同样如果在64位机器上，如果有64个地址线，那一个指针变量的大小就是8个字节，才能存放一个地址。
//总结：
//1.指针变量是用来存放地址的，地址是唯一标识一块地址空间的。
//2.指针的大小在32位平台是4个字节，在64位平台上是8个字节。
//
//64位平台
//
//
//
//32位平台
//
//
//
//二、指针和指针类型
//我们知道，变量有不同的类型，整形，浮点型等。
//那指针有没有类型呢？
//有！！！
//为什么要有不同类型的指针呢？
//
//1.指针解引用
//指针类型的第一个意义：
//
//int main()
//{
//	int a = 0x11223344；
//		int* pa = &a;
//	*pa = 0;
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//
//
//int main()
//{
//	int a = 0x11223344;
//
//	char* pc = (char*)&a;//int *
//	*pc = 0;
//	return 0;
//
//}
//1
//2
//3
//4
//5
//6
//7
//8
//9
//
//对pa解引用的时候改了4个字节，对pc解引用的时候发现只改了一个字节，因为pa是int类型的指针，解引用4个字节，而pc是char类型的指针，只解引用1个字节，指针类型的差异决定了在解引用操作的时候到底访问几个字节，整型指针解引用访问4个字节，字符指针解引用访问1个字节。故指针类型的不同是有意义的！
//可以推广到其他类型…
//
//2.指针±整数
//指针类型的第二个意义 :
//
//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	char* pc = &a;
//
//	printf("pa = %p\n", pa);
//
//	printf("pc = %p\n", pc);
//
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//8
//9
//10
//11
//12
//
//
//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	char* pc = &a;
//
//	printf("pa = %p\n", pa);
//	printf("pa+1 = %p\n", pa + 1);
//
//	printf("pc = %p\n", pc);
//	printf("pc+1 = %p\n", pc + 1);
//
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//8
//9
//10
//11
//12
//13
//14
//
//pa到pa + 1加了四个字节
//pc到pc + 1加了一个字节
//
//结论：指针的类型决定了指针±整数操作时，跳过几个字节
//
//疑问：
//
//int main()
//{
//	int a = 0;
//	int* pi = &a;
//	float* pf = &a;
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//pi解引用访问4个字节，pi + 1也是跳过4个字节
//pf解引用访问4个字节，pf + 1也是跳过4个字节
//int* 和 float* 是不是就可以通用啊？
//很明显不能，为什么呢？
//因为站在pi的角度，它认为它指向的内存里面放的是整型数据，站在pf的角度，它认为它指向的的内存里面放的是浮点型数据。
//观察下面调试数据
//
//int main()
//{
//	int a = 0;
//	int* pi = &a;
//	*pi = 100;
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//
//
//int main()
//{
//	int a = 0;
//	float* pf = &a;
//	*pf = 100.0;
//
//	return 0;
//}
//1
//2
//3
//4
//5
//6
//7
//8
//
//
//它俩对内存的解读方式有很大的差异，所以不能混用！！
//――――――――――――――――
//版权声明：本文为CSDN博主「这代码还能再酷一点吗」的原创文章，遵循CC 4.0 BY - SA版权协议，转载请附上原文出处链接及本声明。
//原文链接：https ://blog.csdn.net/m0_68800221/article/details/125317737