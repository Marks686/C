#define _CRT_SECURE_NO_WARNINGS
文章目录
前言
一、指针数组
二、数组指针
1.数组指针的定义
2. & 数组名vs数组名
3.数组指针的使用
前言
一、指针数组
在初阶我们学习了指针数组，指针数组是一个存放指针的数组，这里我们简单复习下。
指针数组：是数组，是用来存放指针的数组，

int arr[10];//整形数组
char ch[5];//字符数组
//指针数组
int* arr2[6];//这是一个存放整型指针的数组
//arr2数组名，6个元素，数组的每个元素是int*类型的值
//每个元素都是int* 类型的值
char* arr3[5];//存放字符指针的数组
1
2
3
4
5
6
7
指针数组有什么用呢？

int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };

	int* parr[] = { arr1,arr2,arr3 };

	return 0;
}
1
2
3
4
5
6
7
8
9
10
arr1相当于1的地址, arr2相当于2的地址, arr3相当于3的地址。arr1 arr2 arr3都是整型的地址，所以parr这个数组应该是int* 类型的。



int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };

	int* parr[3] = { arr1,arr2,arr3 };

	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 5; j++)
		{
			printf("%d ", *(parr[i] + j));//也可以写成parr[i][j]
		}
		printf("\n");
	}
	return 0;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
打印出来结果：

1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
1
2
3
二、数组指针
1.数组指针的定义
数组指针是指针

类比：

整型指针――指向整型的指针
字符指针――指向字符的指针
数组指针――指向数组的指针

int* p1[10];
int(*p2)[10];
//p1, p2分别是什么？
1
2
3

想要使用数组指针，我们还得先把数组名深入理解一下：

2. & 数组名vs数组名
int main()
{
	int arr[10] = { 0 };
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);
	return 0;
}
1
2
3
4
5
6
7
打印结果：

006FFAD0
006FFAD0
//数组名就是首元素地址
1
2
3
int main()
{
	int arr[10] = { 0 };
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);
	int sz = sizeof(arr);
	printf("%d\n", sz);
	return 0;
}
1
2
3
4
5
6
7
8
9
打印结果：

006FFAD0
006FFAD0
40
1
2
3
当我们这样去写的时候，有的同学就会产生歧义，刚刚我们说了，数组名是首元素地址，如果数组名是首元素地址，首元素地址是地址，所以就是4个字节或者8个字节，那sizeof算出来应该是4 或者 8 ，但是发现结果是40，所以两个地址是一模一样，好像认定了数组名就是首元素地址，但是当我们写sizeof（arr）的时候发现数组名好像不是首元素地址，这个我们要注意：
数组名通常表示的都是数组首元素地址。

但是有两个例外：

1.sizeof（数组名）sizeof里面单独放一个数组名的时候是一个例外，这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节。
2. & 数组名，这里的数组名表示的依然是整个数组，所以 & 数组名，取出的是整个数组的地址。


区别请看下面代码：

int main()
{
	int arr[10] = { 0 };
	printf("%p\n", arr);
	printf("%p\n", arr + 1);

	printf("%p\n", &arr[0]);
	printf("%p\n", &arr[0] + 1);

	printf("%p\n", &arr);
	printf("%p\n", &arr + 1);

	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
打印结果：

00BBFB70
00BBFB74
00BBFB70
00BBFB74
00BBFB70
00BBFB98
1
2
3
4
5
6
我们观察，arr 和arr + 1差了4个字节， & arr[0] 和 & arr[0] + 1差了4个字节，我们发现首元素地址 + 1，加了4个字节，因为我们知道这个数组每个元素都是int类型的，因为数组名表示首元素地址的话，这里就是int类型的地址，那arr的类型是int * ，而int * 的指针 + 1跳过四个字节，所以都是相差4。
那 & arr 和 & arr + 1 相差40，0x28―― > 40, & 数组名，取出的是整个数组的地址，& arr + 1 表示跳过整个数组。

整形指针是用来存放整型的地址
字符指针用来存放字符的地址
数组指针用来存放数组的地址

int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int(*p2)[10] = &arr;//数组指针
	return 0;
}
1
2
3
4
5
6
7
3.数组指针的使用
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*p)[] = &arr;//这样写是不行的
	return 0;
}
1
2
3
4
5
6

warning ： “int(*)[0]”和“int(*)[10]”数组的下标不同，int（ * ）[]认为[]里面是0，两个对不上，所以必须写清楚几个元素，不能省略10！

int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*p)[10] = &arr;

	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < sz; i++)
	{
		printf("%d ", *(*p + i));

	}
	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
p是指向数组的， * p其实就相当于数组名
数组名，又是数组首元素的地址，所以 * p本质上数组首元素地址
1
2
打印结果：

1 2 3 4 5 6 7 8 9 10
1
我们发现这种用法非常的别扭，这种用方法很不好，下面我们看看正常的写法：

int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(p + i));
	}
	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
这种写法就很容易让人理解。

数组指针多用在 二维三维数组里
用数组指针写的话

大概思路：



//用数组传参实现：
void print1(int arr[3][5], int r, int c)
{
	int i = 0;
	for (i = 0; i < r; i++)
	{
		int j = 0;
		for (j = 0; j < c; j++)
		{
			printf("%d ", arr[i][j]);

		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };
	print1(arr, 3, 5);
	return 0;
}
//数组指针的写法：
void print2(int(*p)[5], int r, int c)
{
	int i = 0;
	for (i = 0; i < r; i++)
	{
		int j = 0;
		for (j = 0; j < c; j++)
		{
			printf("%d ", *(*(p + i) + j));
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };
	print2(arr, 3, 5);
	return 0;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
打印结果：

1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
1
2
3
再捋一遍思路：


p我们说指向的是第一行，p + 1为什么就跳过一行呢？

当我们有int(*p)[5]这样一个指针的时候，
p的类型是 : int(*)[5];
p 是指向一个整型数组的，数组是5个元素 int[5]
p + 1就是跳过一个5个int元素的数组。
――――――――――――――――
版权声明：本文为CSDN博主「这代码还能再酷一点吗」的原创文章，遵循CC 4.0 BY - SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https ://blog.csdn.net/m0_68800221/article/details/125476802